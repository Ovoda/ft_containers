#ifndef BASE_HPP
#define BASE_HPP

#ifndef TESTED_NAMESPACE
#define TESTED_NAMESPACE ft
#endif

#include <iostream>
#include <map>
#include <string>

// --- Class foo
template <typename T>
class foo {
 public:
  typedef T value_type;

  foo(void) : value(), _verbose(false){};
  foo(value_type src, const bool verbose = false)
      : value(src), _verbose(verbose){};
  foo(foo const &src, const bool verbose = false)
      : value(src.value), _verbose(verbose){};
  ~foo(void) {
    if (this->_verbose) std::cout << "~foo::foo()" << std::endl;
  };
  void m(void) {
    std::cout << "foo::m called [" << this->value << "]" << std::endl;
  };
  void m(void) const {
    std::cout << "foo::m const called [" << this->value << "]" << std::endl;
  };
  foo &operator=(value_type src) {
    this->value = src;
    return *this;
  };
  foo &operator=(foo const &src) {
    if (this->_verbose || src._verbose)
      std::cout << "foo::operator=(foo) CALLED" << std::endl;
    this->value = src.value;
    return *this;
  };
  value_type getValue(void) const { return this->value; };
  void switchVerbose(void) { this->_verbose = !(this->_verbose); };

  operator value_type(void) const { return value_type(this->value); }

 private:
  value_type value;
  bool _verbose;
};

template <typename T>
std::ostream &operator<<(std::ostream &o, foo<T> const &bar) {
  o << bar.getValue();
  return o;
}
// --- End of class foo

template <typename T>
T inc(T it, int n) {
  while (n-- > 0) ++it;
  return (it);
}

template <typename T>
T dec(T it, int n) {
  while (n-- > 0) --it;
  return (it);
}

#endif /* BASE_HPP */
#if !defined(USING_STD)
#include "map.hpp"
#else
#include <map>
#endif /* !defined(STD) */

#define _pair TESTED_NAMESPACE::pair

template <typename T>
std::string printPair(const T &iterator, bool nl = true,
                      std::ostream &o = std::cout) {
  o << "key: " << iterator->first << " | value: " << iterator->second;
  if (nl) o << std::endl;
  return ("");
}

template <typename T_MAP>
void printSize(T_MAP const &mp, bool print_content = 1) {
  std::cout << "size: " << mp.size() << std::endl;
  std::cout << "max_size: " << mp.max_size() << std::endl;
  if (print_content) {
    typename T_MAP::const_iterator it = mp.begin(), ite = mp.end();
    std::cout << std::endl << "Content is:" << std::endl;
    for (; it != ite; ++it)
      std::cout << "- " << printPair(it, false) << std::endl;
  }
  std::cout << "###############################################" << std::endl;
}

template <typename T1, typename T2>
void printReverse(TESTED_NAMESPACE::map<T1, T2> &mp) {
  typename TESTED_NAMESPACE::map<T1, T2>::iterator it = mp.end(),
                                                   ite = mp.begin();

  std::cout << "printReverse:" << std::endl;
  while (it != ite) {
    it--;
    std::cout << "-> " << printPair(it, false) << std::endl;
  }
  std::cout << "_______________________________________________" << std::endl;
}

#define T1 int
#define T2 std::string
typedef TESTED_NAMESPACE::map<T1, T2>::value_type T3;
typedef TESTED_NAMESPACE::map<T1, T2>::iterator iterator;

static int iter = 0;

template <typename MAP, typename U>
void ft_insert(MAP &mp, U param) {
  _pair<iterator, bool> tmp;

  std::cout << "\t-- [" << iter++ << "] --" << std::endl;
  tmp = mp.insert(param);
  std::cout << "insert return: " << printPair(tmp.first);
  std::cout << "Created new node: " << tmp.second << std::endl;
  printSize(mp);
}

template <typename MAP, typename U, typename V>
void ft_insert(MAP &mp, U param, V param2) {
  iterator tmp;

  std::cout << "\t-- [" << iter++ << "] --" << std::endl;
  tmp = mp.insert(param, param2);
  std::cout << "insert return: " << printPair(tmp);
  printSize(mp);
}

int main(void) {
  TESTED_NAMESPACE::map<T1, T2> mp, mp2;

  ft_insert(mp, T3(42, "lol"));
  ft_insert(mp, T3(42, "mdr"));

  // ft_insert(mp, T3(50, "mdr"));
  // ft_insert(mp, T3(35, "funny"));

  // ft_insert(mp, T3(45, "bunny"));
  // ft_insert(mp, T3(21, "fizz"));
  // ft_insert(mp, T3(38, "buzz"));

  // ft_insert(mp, mp.begin(), T3(55, "fuzzy"));

  // ft_insert(mp2, mp2.begin(), T3(1337, "beauty"));
  // ft_insert(mp2, mp2.end(), T3(1000, "Hello"));
  // ft_insert(mp2, mp2.end(), T3(1500, "World"));

  return (0);
}
